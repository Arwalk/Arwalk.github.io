<!DOCTYPE html>
<html lang="en">
<head>
        <title>Arwalk's blog</title>
        <!-- Fonts -->
        <link href='http://fonts.googleapis.com/css?family=Inconsolata' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=The+Girl+Next+Door' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Marcellus' rel='stylesheet' type='text/css'>
        
        <!-- CSS -->
        <link rel="stylesheet" href="./theme/css/main.css" type="text/css" />
        <link rel="stylesheet" href="./theme/css/pygments.css" type="text/css" />
        <link rel="stylesheet" href="./theme/css/font-awesome.css" type="text/css" />
        <meta charset="utf-8" />
      

        <!-- Javascript-->
        <script async src="http://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
        <script async type="text/javascript"> 
        $(function() {
            function invisibleMenu() {
                var now = 0;
                var pixels = 300;
                var opacity = -1;

                var move = function() {
                    now = $(window).scrollTop();
                    if (now > pixels && opacity !== 0)
                        opacity = 0;
                    else if (now < pixels){
                        // Depends on the position not if scrolls down or up
                        opacity = (1 - now/pixels);
                    }
                    $("div.navigation").css({"opacity": opacity});
                }
                $(window).scroll(move);
                move();
            }
            invisibleMenu();
          });
          </script> 
</head>

<body id="index" class="home">
     <div class="navigation">
        <ol class="nav">
          <li class="current"><a href=".">Blog</a> </li>
          <li><a href="./archives.html">Archive</a></li>
          <li><a href="./tags.html">Tags</a> </li>
          <li><a href="">RSS</a> </li>
        </ol>
      </div>
        <header id="banner" class="body">
                <div class="banner"><a href=".">Arwalk's blog <strong></strong></a></div>
        </header><!-- /#banner -->
        <nav id="menu"><ul>
        </ul></nav><!-- /#menu -->
        <div class="box">
<section id="content" class="body">
  <header class="post">
    <h1 class="entry-title">
      C11: tying data to enums.
    </h1>
  </header>
  <footer class="post-info">
    <abbr>
      Mon 30 September 2019 
         By <a class="url fn" href="./author/arwalk.html">Arwalk</a>
  
    </abbr>
  </footer><!-- /.post-info -->
  <div class="entry-content">
    <div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s say you&#8217;re making a C library that deals with fruits.
Fruits have many "attributes" that could be tied to them.
They could have a size, a color, and a weight, for starters.</p>
</div>
<div class="paragraph">
<p>When you&#8217;re adding a new fruit, you want to be sure to add these attributes too.
So, like many people, you start to use <a href="https://stackoverflow.com/questions/6635851/real-world-use-of-x-macros">X macros</a>. After all, it&#8217;s a typical use.</p>
</div>
<div class="paragraph">
<p>Your lib could look like this:</p>
</div>
<div class="listingblock">
<div class="title">fruits.h</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c"># pragma once

#include &lt;inttypes.h&gt;

typedef enum
{
    COLOR_GREEN,
    COLOR_YELLOW,
    COLOR_RED,
} color_e;

// enum, weight, size, color, name
#define FRUIT_TABLE \
    X(FRUITS_APPLE, 50, 10, COLOR_GREEN, "Apple") \
    X(FRUITS_BANANA, 100, 20, COLOR_YELLOW, "Banana") \
    X(FRUITS_STRAWBERRY, 10, 2, COLOR_RED, "Strawberry") \
    X(FRUITS_PEACH, 45, 12, COLOR_RED, "Peach") \

typedef enum
{
    #define X(enum, weight, size, color, name) enum,
    FRUIT_TABLE
    #undef X
} fruits_e;

uint32_t get_weight(fruits_e fruit);
uint32_t get_size(fruits_e fruit);
color_e  get_color(fruits_e fruit);
const char*    get_name(fruits_e fruit);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">fruits.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include "fruits.h"

struct my_data_array_s
{
    fruits_e fruit;
    uint32_t weight;
    uint32_t size;
    color_e color;
    const char* name;
} data_array[]=
{
    #define X(enum, weight, size, color, name) {enum, weight, size, color, name},
    FRUIT_TABLE
    #undef X
};

#define SIZE_data_array (sizeof(data_array)/sizeof(data_array[0]))

uint32_t get_weight(fruits_e fruit)
{
    for(int i = 0; i &lt; SIZE_data_array; i++)
    {
        if(data_array[i].fruit == fruit)
        {
            return data_array[i].weight;
        }
    }
    return 0;
}

uint32_t get_size(fruits_e fruit)
{
    for(int i = 0; i &lt; SIZE_data_array; i++)
    {
        if(data_array[i].fruit == fruit)
        {
            return data_array[i].size;
        }
    }
    return 0;
}

color_e get_color(fruits_e fruit)
{
    for(int i = 0; i &lt; SIZE_data_array; i++)
    {
        if(data_array[i].fruit == fruit)
        {
            return data_array[i].color;
        }
    }
    return 0;
}

const char* get_name(fruits_e fruit)
{
    for(int i = 0; i &lt; SIZE_data_array; i++)
    {
        if(data_array[i].fruit == fruit)
        {
            return data_array[i].name;
        }
    }
    return "";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using X macros ensures that if you add a new fruit in the list, you have to add its attributes too.
This then populates automatically the data_array with the new value and attributes, and you can&#8217;t forget to update this array.</p>
</div>
<div class="paragraph">
<p>That&#8217;s the big pro of X macros. It allows you to define a bunch of information in a single place, and reuse it easily.</p>
</div>
<div class="paragraph">
<p>In our case though, it has a big con. Namely, you&#8217;re breaking the first rule of implementation in interfaces:</p>
</div>
<div class="paragraph">
<p><strong>You don&#8217;t talk about implementation in interfaces.</strong></p>
</div>
<div class="paragraph">
<p>The data in data_array is strictly implementation detail. If data about the fruits where to be dynamically loaded (through a file, for example) at a later point,
You still gave the opportunity to the user to use the details directly. And remember: the user will always do stupid shit with your interface. <em>Remember that you too are someone else&#8217;s user.</em></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_fix">The fix</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Considering the user&#8217;s behavior, you have no choice but to leave the minimum of information on your interface. Namely, the enum itself.</p>
</div>
<div class="listingblock">
<div class="title">fruits.h</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c"># pragma once

#include &lt;inttypes.h&gt;

typedef enum
{
    COLOR_GREEN,
    COLOR_YELLOW,
    COLOR_RED,
} color_e;

typedef enum
{
    FRUITS_APPLE,
    FRUITS_BANANA,
    FRUITS_STRAWBERRY,
    FRUITS_PEACH,
} fruits_e;

uint32_t get_weight(fruits_e fruit);
uint32_t get_size(fruits_e fruit);
color_e  get_color(fruits_e fruit);
const char*    get_name(fruits_e fruit);</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">fruits.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#include "fruits.h"

struct my_data_array_s
{
    fruits_e fruit;
    uint32_t weight;
    uint32_t size;
    color_e color;
    const char* name;
} data_array[]=
{
    {FRUITS_APPLE, 50, 10, COLOR_GREEN, "Apple"},
    {FRUITS_BANANA, 100, 20, COLOR_YELLOW, "Banana"},
    {FRUITS_STRAWBERRY, 10, 2, COLOR_RED, "Strawberry"},
    {FRUITS_PEACH, 45, 12, COLOR_RED, "Peach"},
};

#define SIZE_data_array (sizeof(data_array)/sizeof(data_array[0]))</code></pre>
</div>
</div>
<div class="paragraph">
<p>But now, you don&#8217;t have this guarantee that you won&#8217;t forget to update data_array at compile time if you add a new enum value, like with the X macro.</p>
</div>
<div class="paragraph">
<p>Luckily, you are working in a relatively modern environment. And you have access to C11. So you can actually enforce this.</p>
</div>
<div class="paragraph">
<p>To make it short, you have to ensure at compile time that size of data_array is the same as the number of values in fruits_e.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start by adding a "num value" value to our enum.</p>
</div>
<div class="listingblock">
<div class="title">fruits.h</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">typedef enum
{
    FRUITS_APPLE,
    FRUITS_BANANA,
    FRUITS_STRAWBERRY,
    FRUITS_PEACH,

    FRUITS_NUM_VALUE, // keep last
} fruits_e;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And now, we just need to assert at compile time that <code>FRUITS_NUM_VALUE == SIZE_data_array</code>.</p>
</div>
<div class="paragraph">
<p>C11 offers the <code>_Static_assert</code> keyword. Let&#8217;s try it.</p>
</div>
<div class="listingblock">
<div class="title">fruits.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">struct my_data_array_s
{
    fruits_e fruit;
    uint32_t weight;
    uint32_t size;
    color_e color;
    const char* name;
} data_array[]=
{
    {FRUITS_APPLE, 50, 10, COLOR_GREEN, "Apple"},
    {FRUITS_BANANA, 100, 20, COLOR_YELLOW, "Banana"},
    {FRUITS_STRAWBERRY, 10, 2, COLOR_RED, "Strawberry"},
    {FRUITS_PEACH, 45, 12, COLOR_RED, "Peach"},
};

#define SIZE_data_array (sizeof(data_array)/sizeof(data_array[0]))

_Static_assert(FRUITS_NUM_VALUE == SIZE_data_array, "Some data is missing in data_array.");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, if i add a new value in my fruits_e enum&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="title">fruits.h</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">typedef enum
{
    FRUITS_APPLE,
    FRUITS_BANANA,
    FRUITS_STRAWBERRY,
    FRUITS_PEACH,
    FRUITS_PEAR,

    FRUITS_NUM_VALUE, // keep last
} fruits_e;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It breaks at compile time.</p>
</div>
<div class="listingblock">
<div class="title">error</div>
<div class="content">
<pre class="pygments highlight"><code>../src/lib/fruits.c:20:1: error: static assertion failed: "Some data is missing in data_array."
 _Static_assert(FRUITS_NUM_VALUE == SIZE_data_array, "Some data is missing in data_array.");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thats nice! We now have the same verification at compile time than the X macro.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_but_wait_my_enum_has_skips">But wait, my enum has skips!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This tricks only works if your enum starts from 0 and has no specific values or skips.
FRUITS_NUM_VALUES would not actually be the size of the enum in this case, even if last.</p>
</div>
<div class="paragraph">
<p>So what could we do if your enum actually looked like this?</p>
</div>
<div class="listingblock">
<div class="title">fruits.h</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">typedef enum
{
    FRUITS_APPLE = 10,
    FRUITS_BANANA= 20,
    FRUITS_STRAWBERRY = 30,
    FRUITS_PEACH = 40,
} fruits_e;</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s easy. We&#8217;re gonna go back to X macros!</p>
</div>
<div class="paragraph">
<p>They will allow us to define the enum the way we want, and to <a href="https://stackoverflow.com/a/25354018/11561171">count the number of elements in our enum</a> at the same time.</p>
</div>
<div class="listingblock">
<div class="title">fruits.h</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">#define FRUIT_TABLE \
    X(FRUITS_APPLE, 10) \
    X(FRUITS_BANANA, 20) \
    X(FRUITS_STRAWBERRY, 30) \
    X(FRUITS_PEACH, 40)

typedef enum
{
#define X(enum, value) enum = value,
    FRUIT_TABLE
#undef X
} fruits_e;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">fruits.c</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="c">struct my_data_array_s
{
    fruits_e fruit;
    uint32_t weight;
    uint32_t size;
    color_e color;
    const char* name;
} data_array[]=
{
    {FRUITS_APPLE, 50, 10, COLOR_GREEN, "Apple"},
    {FRUITS_BANANA, 100, 20, COLOR_YELLOW, "Banana"},
    {FRUITS_STRAWBERRY, 10, 2, COLOR_RED, "Strawberry"},
    {FRUITS_PEACH, 45, 12, COLOR_RED, "Peach"},
};

#define SIZE_data_array (sizeof(data_array)/sizeof(data_array[0]))

#define X(enum, value) + 1
// This will expand to "+ 1" for each entry in FRUIT_TABLE.
#define FRUITS_NUM_VALUE (0 FRUIT_TABLE)
_Static_assert(FRUITS_NUM_VALUE == SIZE_data_array, "Some data is missing in data_array.");
#undef X</code></pre>
</div>
</div>
<div class="paragraph">
<p>Sadly, because of how the preprocessor works, we can&#8217;t define FRUITS_NUM_VALUE in our interface.
But it&#8217;s not a big deal, because we now have access to this enum through a X macro, which allow us to make this kind of stuff.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_in_the_end_were_back_to_x_macros">In the end, we&#8217;re back to X macros.</h2>
<div class="sectionbody">
<div class="paragraph">
<p>X macros are powerful tools, but you should be careful not to expose any detail of your implementation
if you are using them in a header. With C11, you have the possibility to have the same level of compile-time check
using <code>_Static_assert</code>, making them much more interesting to use directly.</p>
</div>
<div class="paragraph">
<p>If you&#8217;re not using them in any interface though, you&#8217;re free to do it the way you want. Just be careful from the evil users.</p>
</div>
</div>
</div>

  </div><!-- /.entry-content -->
</section>
            <hr/>
            <footer id="contentinfo" class="footer">
                <div>
                    <a href=".">Arwalk</a> (2012)
                </div>
                <div>
                    This work is licensed under <a rel="license" href="http://opensource.org/licenses/bsd-3-clause">3 clause BSD</a>. Source code available on <a rel="source code" href="https://github.com/slok/blog">Github</a>
                </div>
                <div>
                    powered by <a href="http://getpelican.com/">Pelican</a>
                    and <a href="http://python.org">Python</a>. 
                    <a href="http://github.com/slok/iris">Theme</a> by <a href="http://xlarrakoetxea.org">Xabier Larrakoetxea</a> based on <a href="http://flask.pocoo.org/">Flask</a> theme
                </div>
                <div>
                    Social icons (font awesome) by <a href="http://fortawesome.github.com/Font-Awesome/"> fort awesome</a>.
                    <a href="http://www.google.com/webfonts/specimen/The+Girl+Next+Door">Title</a>, <a href="http://www.google.com/webfonts/specimen/Marcellus">headers</a> and <a href="http://www.google.com/webfonts/specimen/Inconsolata">source code</a> fonts by google fonts
                </div>
                <div class="social">
                </div>
            </footer><!-- /#contentinfo -->
        </div>
        <!--Add statistycs-->

</body>
</html>